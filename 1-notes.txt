What is an ADT?

    An abstraction of concrete data structures (ds). It's the interface, and contract that ds must adhere to.

    The interface hides the details and complexity of the ds implementation.


Examples: 

    ADT (Interface)                         DS (Implementation)
    List                                    Dynamic Array, Linked List
    Queue / Stack                           Dynamic Array, Linked List
    Map                                     Hash Map, Tree Map


Arrays:

    1. Static arrays: hold a fixed length of elements.

        Stored in RAM memory, keeps track of the first block memory address and we know it's consecutively
        stored from there.

    2. Dynamic arrays: hold a dynamic length of elements.

    Useful for making lists of items, or storing related data.

    Insertion (constant time complexity):
        
        push(value)         -       insertion to end of array
        
        arr[i] = value      -       direct insertion in specified index
        
        unshift(value)      -       insertion to front of array

    Time Complexity:

        Operation               Cost
        Read                    O(1)
        Write                   O(1)
        Update                  O(1)
        Delete                  O(n) shifting elements to the right or left, then changing the size of the array
        Search                  O(n) looping through n elements to find an element


Linked Lists:

    A linear data structure where the elements are not stored in contiguous memory locations, instead the elements
    are linked using pointers.

    It contains a head and optionally a tail. The pointer points to the next node in the Singly Linked List (SLL).

    Usage:

        Spotify Music Playlist

        Stacks

        Queues

    Doubly Linked Lists (DLL) have pointers to its next and previous node.

    Time Complexity:

        Operation           SLL         DLL
        Insertion head      O(1)        O(1)
        Insertion middle    O(n)        O(n)
        Insertion tail      O(1)        O(1)


Stacks:

    A stack is a linear data structure.

    Unlike the array and linked list, a stock only supports insertion and deletion from the top of the stack.

    LIFO ordering (Last In, First Out).

    Pushing data in & Popping data out.

    Usage:

        Browser history (back, next).

        Call stack in JS runtime / event loop.

        Graph algorithms - DFS & BFS.

    Implementation:

        Using a Doubly Linked List, pop from tail (top of the stack), push to tail.

    Time Complexity:

        Operation           Stack
        Push                O(1)
        Pop                 O(1)
        Peek                O(1)


Queues:

    A queue is a linear data structure.

    Unlike the array and linked list, a queue only supports insertion and deletion from the ends of the list.

    Similar to waiting in line to pay at a store.

    We delete from the front of the queue (dequeue) and we add to the back of the queue (enqueue).

    FIFI ordering (First In, First Out).

    Usage:

        Output Streams (transferring data).

        Graph algorithms - DFS & BFS.

    Implementation:

        Using a Doubly Linked List, pop from head (front of the queue), push to tail (back of the queue).

    Time Complexity:

        Operation           Stack
        Enqueue             O(1)
        Dequeue             O(1)
        Peek Front          O(1)
        Peek Back           O(1)


Circular Buffer:

    A circular buffer is a single, fixed-size buffer which is connected from end-to-end.

    Other names for this ADT are: circular queue, cyclic buffer, and ring buffer.

    FIFO ordering (First In, First Out), similar to a queue, but it has a fixed capacity.

    Circular buffers can also be implemented with overwriting enabled.

    Frequently used when the input and output to a data stream occur at different rates.

    Implementation:

        Two Indexes:
        
            readIndex - the element where we should pull the element from (front of the queue)

            writeIndex - the element where we should add the new element (back of the queue)

        Since the size is fixed, the writeIndex & readIndex goes back to index 0 after the last element index is reached.

    Time Complexity:

        Operation           Stack
        Enqueue             O(1)
        Dequeue             O(1)
        Peek Front          O(1)
        Peek Back           O(1)
